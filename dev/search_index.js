var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Docstrings for Mehrotra.jl interface members can be accessed through Julia's built-in documentation system or in the list below.","category":"page"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Mehrotra","category":"page"},{"location":"api.html#Contents","page":"API Documentation","title":"Contents","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#Index","page":"API Documentation","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#Solver","page":"API Documentation","title":"Solver","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"    Solver\n    solve!\n    initialize!\n    Options","category":"page"},{"location":"contributing.html#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Contributions are always welcome!","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"If you want to contribute features, bug fixes, etc, please take a look at our Code Style Guide below\nPlease report any issues and bugs that you encounter in Issues\nAs an open source project we are also interested in any projects and applications that use Mehrotra. Please let us know via email to: simonlc@stanford.edu","category":"page"},{"location":"contributing.html#Potentially-Useful-Contributions","page":"Contributing","title":"Potentially Useful Contributions","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Here are a list of current to-do's that would make awesome contributions:","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"support for sparse FiniteDiff, ForwardDiff derivatives\nsupport for additional linear-system solvers like: Pardiso, HSL, or Krylov\nintegration with ChainRules\nprecompilation\nPython + JAX/Torch wrapper","category":"page"},{"location":"contributing.html#Code-Style-Guide","page":"Contributing","title":"Code Style Guide","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"The code in this repository follows the naming and style conventions of Julia Base with a few modifications. This style guide is heavily \"inspired\" by the guides of John Myles White, JuMP, and COSMO","category":"page"},{"location":"contributing.html#Formatting","page":"Contributing","title":"Formatting","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use one tab when indenting a new block (except module)\nUse spaces between operators, except for ^, ', and :\nUse single space after commas and semicolons\nDon't use spaces around parentheses, or braces","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: f(x,y) = [5*sin(x+y);y'] Good: f(x, y) = [5 * sin(x + y); y']","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use spacing with keyword arguments","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: foo(x::Float; y::Integer = 1) Good: foo(x::Float; y::Integer=1)","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Don't parenthesize conditions","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: if (a == b) Good: if a == b","category":"page"},{"location":"contributing.html#Naming","page":"Contributing","title":"Naming","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Modules and Type names use capitilization and camel case, e.g. module LinearAlgebra, struct ConvexSets.\nFunctions are lowercase and use underscores to seperate words, e.g. has_key(x), is_valid(y).\nNormal variables are lowercase and use underscores like functions, e.g. convex_set\nConstants are uppercase, e.g. const MY_CONSTANT\nAlways append ! to names of functions that modify their arguments.\nFunction arguments that are mutated come first. Otherwise follow the rules layed out in Julia Base Argument ordering\nFiles are named like functions, e.g. my_new_file.jl","category":"page"},{"location":"contributing.html#Syntax","page":"Contributing","title":"Syntax","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use 1.0 instead of 1.","category":"page"},{"location":"solver.html#Solver","page":"Solver","title":"Solver","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"Mehrotra is a solver for non-convex optimization problems designed for robotics applications with conic and complementarity constraints. Additionally, solutions are differentiable with respect to problem data provided to the solver.","category":"page"},{"location":"solver.html#Standard-form","page":"Solver","title":"Standard form","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"Problems:","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"beginalign*\nundersetxtextminimize  quad c(x theta) \ntextsubject to  quad  g(x theta) = 0 \n                   quad  h(x theta) in mathcalK \nendalign*","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"with","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"x in mathbfR^n: decision variables  \ntheta in mathbfR^d: problem data  ","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"are optimized for","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"c  mathbfR^n times mathbfR^d rightarrow mathbfR: objective\ng  mathbfR^n times mathbfR^d rightarrow mathbfR^m: equality constraints\nh  mathbfR^n times mathbfR^d rightarrow mathbfR^p:  cone constraints","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"The cone,","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"mathcalK = mathbfR_++^q times Q_l_1^(1) times dots times Q_l_j^(j)","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"is the Cartesian product of the q-dimensional nonnegative orthant and j second-order cones, each of dimension l_i.","category":"page"},{"location":"solver.html#Non-convex-problem-example","page":"Solver","title":"Non-convex problem example","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"In the following example, we formulate and solve the Wächter problem that motivated many of the algorithms and heuristics developed for Ipopt:","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"using CALIPSO\n\n# problem\nobjective(x) = x[1]\nequality(x) = [x[1]^2 - x[2] - 1.0; x[1] - x[3] - 0.5]\ncone(x) = x[2:3]\n\n# variables\nnum_variables = 3\n\n# solver\nsolver = Solver(objective, equality, cone, num_variables);\n\n# initialize\nx0 = [-2.0, 3.0, 1.0]\ninitialize!(solver, x0)\n\n# solve\nsolve!(solver)\n\n# solution\nsolver.solution.variables # x* = [1.0, 0.0, 0.5]","category":"page"},{"location":"solver.html#Trajectory-optimization","page":"Solver","title":"Trajectory optimization","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"Deterministic Markov Decision Processes,","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"beginalign*\n\t\tundersetX_1T phantom U_1T-1textminimize   C_T(X_T theta_T) + sum limits_t = 1^T-1 C_t(X_t U_t theta_t) \n\t\ttextsubject to   F_t(X_t U_t theta_t) = X_t+1 quad t = 1dotsT-1 \n\t\t E_t(X_t U_t theta_t) = 0 phantom _t+1 quad t = 1 dots T \n\t\t H_t(X_t U_t theta_t) in mathcalK_t phantomX quad t = 1 dots T\nendalign*","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"with","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"X_t in mathbfR^n_t: state\nU_t in mathbfR^m_t: action\ntheta_t in mathbfR^d_t: problem data","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"and","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"C_t  mathbfR^n_t times mathbfR^m_t times mathbfR^d_t rightarrow mathbfR: stage cost\nF_t  mathbfR^n_t times mathbfR^m_t times mathbfR^d_t rightarrow mathbfR^n_t+1: discrete-time dynamics\nE_t  mathbfR^n_t times mathbfR^m_t times mathbfR^d_t rightarrow mathbfR^e_t: equality constraint\nH_t  mathbfR^n_t times mathbfR^m_t times mathbfR^d_t rightarrow mathbfR^h_t: cone constraints","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"are automatically transcribed and optimized with CALIPSO.","category":"page"},{"location":"solver.html#Pendulum-swing-up-example","page":"Solver","title":"Pendulum swing-up example","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"In the following example, we optimize state and action trajectories in order to perform a swing-up with a pendulum system:","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"using CALIPSO\nusing LinearAlgebra\n\n# horizon\nhorizon = 11\n\n# dimensions\nnum_states = [2 for t = 1:horizon]\nnum_actions = [1 for t = 1:horizon-1]\n\n# dynamics\nfunction pendulum_continuous(x, u)\n   mass = 1.0\n   length_com = 0.5\n   gravity = 9.81\n   damping = 0.1\n\n   [\n      x[2],\n      (u[1] / ((mass * length_com * length_com))\n            - gravity * sin(x[1]) / length_com\n            - damping * x[2] / (mass * length_com * length_com))\n   ]\nend\n\nfunction pendulum_discrete(y, x, u)\n   h = 0.05 # timestep\n   y - (x + h * pendulum_continuous(0.5 * (x + y), u))\nend\n\ndynamics = [pendulum_discrete for t = 1:horizon-1]\n\n# states\nstate_initial = [0.0; 0.0]\nstate_goal = [π; 0.0]\n\n# objective\nobjective = [\n   [(x, u) -> 0.1 * dot(x[1:2], x[1:2]) + 0.1 * dot(u, u) for t = 1:horizon-1]...,\n   (x, u) -> 0.1 * dot(x[1:2], x[1:2]),\n];\n\n# constraints\nequality = [\n      (x, u) -> x - state_initial,\n      [empty_constraint for t = 2:horizon-1]...,\n      (x, u) -> x - state_goal,\n];\n\n# solver\nsolver = Solver(objective, dynamics, num_states, num_actions;\n   equality=equality);\n\n# initialize\nstate_guess = linear_interpolation(state_initial, state_goal, horizon)\naction_guess = [1.0 * randn(num_actions[t]) for t = 1:horizon-1]\ninitialize_states!(solver, state_guess)\ninitialize_actions!(solver, action_guess)\n\n# solve\nsolve!(solver)\n\n# solution\nstate_solution, action_solution = get_trajectory(solver);","category":"page"},{"location":"solver.html#Solution-gradients","page":"Solver","title":"Solution gradients","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"The solutions returned by CALIPSO are differentiable with respect to problem data provided to the solver.","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"    fracpartial wpartial theta = -Big(fracpartial Rpartial wBig)^-1 fracpartial Rpartial theta","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"Sensitivities are efficiently computing via the implicit-function theorem. This functionality can be utilized by setting the solver option: differentiate = true.","category":"page"},{"location":"solver.html#Differentiable-trajectory-optimization-example","page":"Solver","title":"Differentiable trajectory-optimization example","text":"","category":"section"},{"location":"solver.html","page":"Solver","title":"Solver","text":"In the following example we demonstrate how problem data can be provided to the solver in order to get gradients of the solution with respect to these values. For more advanced usage, see our auto-tuning examples.","category":"page"},{"location":"solver.html","page":"Solver","title":"Solver","text":"using CALIPSO\nusing LinearAlgebra\n\n# horizon\nhorizon = 5\n\n# dimensions\nnum_states = [2 for t = 1:horizon]\nnum_actions = [1 for t = 1:horizon-1]\n\n# dynamics\nfunction double_integrator(y, x, u, w)\n\tA = reshape(w[1:4], 2, 2)\n\tB = w[4 .+ (1:2)]\n\n\treturn y - (A * x + B * u[1])\nend\n\n# model\ndynamics = [double_integrator for t = 1:horizon-1]\n\n# parameters\nstate_initial = [0.0; 0.0]\nstate_goal = [1.0; 0.0]\n\nA = [1.0 1.0; 0.0 1.0]\nB = [0.0; 1.0]\nQt = [1.0 0.0; 0.0 1.0]\nRt = [0.1]\nQT = [10.0 0.0; 0.0 10.0]\nθ1 = [vec(A); B; diag(Qt); Rt; state_initial]\nθt = [vec(A); B; diag(Qt); Rt]  \nθT = [diag(QT); state_goal]\nparameters = [θ1, [θt for t = 2:horizon-1]..., θT]\n\n# objective\nfunction obj1(x, u, w)\n\tQ1 = Diagonal(w[6 .+ (1:2)])\n\tR1 = w[8 + 1]\n\treturn 0.5 * transpose(x) * Q1 * x + 0.5 * R1 * transpose(u) * u\nend\n\nfunction objt(x, u, w)\n\tQt = Diagonal(w[6 .+ (1:2)])\n\tRt = w[8 + 1]\n\treturn 0.5 * transpose(x) * Qt * x + 0.5 * Rt * transpose(u) * u\nend\n\nfunction objT(x, u, w)\n\tQT = Diagonal(w[0 .+ (1:2)])\n\treturn 0.5 * transpose(x) * QT * x\nend\n\nobjective = [\n\t\t\t\tobj1,\n\t\t\t\t[objt for t = 2:horizon-1]...,\n\t\t\t\tobjT,\n]\n\n# constraints\nequality = [\n\t\t(x, u, w) -> 1 * (x - w[9 .+ (1:2)]),\n\t\t[empty_constraint for t = 2:horizon-1]...,\n\t\t(x, u, w) -> 1 * (x - w[2 .+ (1:2)]),\n]\n\n# options\noptions = Options(\n\t\tresidual_tolerance=1.0e-12,\n\t\tequality_tolerance=1.0e-8,\n\t\tcomplementarity_tolerance=1.0e-8,\n\t\tdifferentiate=true) # <--- setting to get solution gradients\n\n# solver\nsolver = Solver(objective, dynamics, num_states, num_actions;\n\tparameters=parameters,\n\tequality=equality,\n\toptions=options);\n\n# initialize\nstate_guess = linear_interpolation(state_initial, state_goal, horizon)\naction_guess = [1.0 * randn(num_actions[t]) for t = 1:horizon-1]\ninitialize_states!(solver, state_guess)\ninitialize_actions!(solver, action_guess)\n\n# solve\nsolve!(solver)\n\n# solution\nstate_solution, action_solution = get_trajectory(solver);","category":"page"},{"location":"index.html#Get-Started","page":"Get Started","title":"Get Started","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Mehrotra is a differentiable solver for nonlinear complementarity problems with conic constraints. The solver is written in pure Julia in order to be both performant and easy to use.","category":"page"},{"location":"index.html#Features","page":"Get Started","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Differentiable: Solutions are efficiently differentiable with respect to problem data provided to the solver\nSecond-Order-Cone Constraints: Cone constraints are natively supported in the non-convex problem setting\nCodegen for Derivatives: User-provided functions (e.g., objective, constraints) are symbolically differentiated and fast code is autogenerated using Symbolics.jl\nOpen Source: Code is available on GitHub and distributed under the MIT Licence","category":"page"},{"location":"index.html#Installation","page":"Get Started","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Mehrotra can be installed using the Julia package manager for Julia v1.7 and higher. Inside the Julia REPL, type ] to enter the Pkg REPL mode then run:","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"pkg> add Mehrotra","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"If you want to install the latest version from Github run:","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"pkg> add Mehrotra#main","category":"page"},{"location":"index.html#Citation","page":"Get Started","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"If this project is useful for your work please consider:","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Citing the relevant paper\nLeaving a star on the GitHub repository","category":"page"},{"location":"index.html#Licence","page":"Get Started","title":"Licence","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Mehrotra is licensed under the MIT License. For more details click here.","category":"page"},{"location":"citing.html#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citing.html","page":"Citing","title":"Citing","text":"If you find Mehrotra useful in your project, we kindly request that you cite the following paper:","category":"page"},{"location":"citing.html","page":"Citing","title":"Citing","text":"@article{lecleach2022mehrotra,\n\ttitle={title},\n\tauthor={author},\n\tyear={2022}\n}","category":"page"},{"location":"citing.html","page":"Citing","title":"Citing","text":"A preprint can be downloaded from arXiv.","category":"page"}]
}
